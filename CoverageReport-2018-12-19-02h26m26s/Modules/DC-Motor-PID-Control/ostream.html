<!doctype html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>ostream</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
// ostream standard header
#pragma once
#ifndef _OSTREAM_
#define _OSTREAM_
#ifndef RC_INVOKED
#include &lt;ios&gt;

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 _STL_DISABLE_CLANG_WARNINGS
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// I/O EXCEPTION MACROS

 #if _HAS_EXCEPTIONS
 #define _TRY_IO_BEGIN	_TRY_BEGIN	/* begin try block */

 #define _CATCH_IO_END	_CATCH_ALL	/* catch block for _Myios */ \
	_Myios::setstate(ios_base::badbit, true);	/* set badbit and rethrow */ \
	_CATCH_END

 #define _CATCH_IO_(x)	_CATCH_ALL	/* catch block for basic_ios x */ \
	(x).setstate(ios_base::badbit, true);	/* set badbit and rethrow */ \
	_CATCH_END

 #else /* _HAS_EXCEPTIONS */
 #define _TRY_IO_BEGIN	{	/* begin try block */
 #define _CATCH_IO_END	}	/* catch block for _Myios */
 #define _CATCH_IO_(x)	}	/* catch block for basic_ios x */
 #endif /* _HAS_EXCEPTIONS */

 #pragma vtordisp(push, 2)	// compiler bug workaround

		// CLASS TEMPLATE basic_ostream
template&lt;class _Elem,
	class _Traits&gt;
	class basic_ostream
		: virtual public basic_ios&lt;_Elem, _Traits&gt;
	{	// control insertions into a stream buffer
public:
	typedef basic_ios&lt;_Elem, _Traits&gt; _Myios;
	typedef basic_streambuf&lt;_Elem, _Traits&gt; _Mysb;
	typedef ostreambuf_iterator&lt;_Elem, _Traits&gt; _Iter;
	typedef num_put&lt;_Elem, _Iter&gt; _Nput;

	explicit __CLR_OR_THIS_CALL basic_ostream(
		basic_streambuf&lt;_Elem, _Traits&gt; *_Strbuf,

		bool _Isstd = false)
		{	// construct from a stream buffer pointer
		_Myios::init(_Strbuf, _Isstd);
		}

	__CLR_OR_THIS_CALL basic_ostream(_Uninitialized, bool _Addit = true)
		{	// construct uninitialized
		if (_Addit)
			this-&gt;_Addstd(this);	// suppress for basic_iostream
		}

protected:
	__CLR_OR_THIS_CALL basic_ostream(basic_ostream&amp;&amp; _Right)
		{	// construct by moving _Right
		_Myios::init();
		_Myios::move(_STD move(_Right));
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator=(basic_ostream&amp;&amp; _Right)
		{	// move from _Right
		this-&gt;swap(_Right);
		return (*this);
		}

	void __CLR_OR_THIS_CALL swap(basic_ostream&amp; _Right)
		{	// swap with _Right
		if (this != _STD addressof(_Right))
			_Myios::swap(_Right);
		}

public:
	__CLR_OR_THIS_CALL basic_ostream(const basic_ostream&amp;) = delete;
	basic_ostream&amp; __CLR_OR_THIS_CALL operator=(const basic_ostream&amp;) = delete;

	virtual __CLR_OR_THIS_CALL ~basic_ostream() noexcept
		{	// destroy the object
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	class _Sentry_base
		{	// stores thread lock and reference to output stream
	public:
		__CLR_OR_THIS_CALL _Sentry_base(basic_ostream&amp; _Ostr)
<span style = "background-color:#dfd">			: _Myostr(_Ostr)
			{	// lock the stream buffer, if there
			if (_Myostr.rdbuf() != nullptr)
				_Myostr.rdbuf()-&gt;_Lock();
			}</span>

		__CLR_OR_THIS_CALL ~_Sentry_base() noexcept
<span style = "background-color:#dfd">			{	// destroy after unlocking
			if (_Myostr.rdbuf() != nullptr)
				_Myostr.rdbuf()-&gt;_Unlock();
			}</span>

		basic_ostream&amp; _Myostr;	// the output stream, for _Unlock call at destruction

		_Sentry_base&amp; operator=(const _Sentry_base&amp;) = delete;
		};

	class sentry
		: public _Sentry_base
		{	// stores thread lock and state of stream
	public:
		explicit __CLR_OR_THIS_CALL sentry(basic_ostream&amp; _Ostr)
<span style = "background-color:#dfd">			: _Sentry_base(_Ostr)
			{	// construct locking and testing stream
			if (_Ostr.good() &amp;&amp; _Ostr.tie() != nullptr &amp;&amp; _Ostr.tie() != &amp;_Ostr)</span>
<span style = "background-color:#fdd">				_Ostr.tie()-&gt;flush();</span>
<span style = "background-color:#dfd">			_Ok = _Ostr.good();	// store test only after flushing tie
			}</span>

 #ifdef __clang__
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wdeprecated-declarations"
 #else  /* ^^^ clang ^^^ / vvv not clang vvv  */
  #pragma warning(push)
  #pragma warning(disable: 4996)	// was declared deprecated
 #endif /* __clang__ */
		__CLR_OR_THIS_CALL ~sentry() noexcept
<span style = "background-color:#dfd">			{	// destroy the object</span>
 #if _HAS_EXCEPTIONS
<span style = "background-color:#dfd">			if (!_STD uncaught_exception())	// TRANSITION, OS#15518458</span>
				{
<span style = "background-color:#dfd">				this-&gt;_Myostr._Osfx();</span>
				}
 #else /* _HAS_EXCEPTIONS */
			this-&gt;_Myostr._Osfx();
 #endif /* _HAS_EXCEPTIONS */
<span style = "background-color:#dfd">			}</span>
 #ifdef __clang__
  #pragma clang diagnostic pop
 #else  /* ^^^ clang ^^^ / vvv not clang vvv  */
  #pragma warning(pop)
 #endif /* __clang__ */

		explicit __CLR_OR_THIS_CALL operator bool() const
<span style = "background-color:#dfd">			{	// test if stream state okay
			return (_Ok);
			}</span>

		__CLR_OR_THIS_CALL sentry(const sentry&amp;) = delete;
		sentry&amp; __CLR_OR_THIS_CALL operator=(const sentry&amp;) = delete;

	private:
		bool _Ok;	// true if stream state okay at construction
		};

	bool __CLR_OR_THIS_CALL opfx()
		{	// test stream state and flush tie stream as needed (retained)
		if (this-&gt;good() &amp;&amp; _Myios::tie() != nullptr &amp;&amp; _Myios::tie() != this)
			_Myios::tie()-&gt;flush();
		return (this-&gt;good());
		}

	void __CLR_OR_THIS_CALL osfx()
		{	// perform any wrapup (retained)
		_Osfx();
		}

	void __CLR_OR_THIS_CALL _Osfx()
		{	// perform any wrapup
		_TRY_BEGIN
		if (this-&gt;good() &amp;&amp; this-&gt;flags() &amp; ios_base::unitbuf)
			if (_Myios::rdbuf()-&gt;pubsync() == -1)	// flush stream as needed
				_Myios::setstate(ios_base::badbit);
		_CATCH_ALL
		_CATCH_END
		}

  #ifdef _M_CEE_PURE
	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(basic_ostream&amp; (__clrcall *_Pfn)(basic_ostream&amp;))
		{	// call basic_ostream manipulator
		return ((*_Pfn)(*this));
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(_Myios&amp; (__clrcall *_Pfn)(_Myios&amp;))
		{	// call basic_ios manipulator
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(ios_base&amp; (__clrcall *_Pfn)(ios_base&amp;))
		{	// call ios_base manipulator
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}
  #endif /* _M_CEE_PURE */

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(basic_ostream&amp; (__cdecl *_Pfn)(basic_ostream&amp;))
		{	// call basic_ostream manipulator
		return ((*_Pfn)(*this));
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(_Myios&amp; (__cdecl *_Pfn)(_Myios&amp;))
		{	// call basic_ios manipulator
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(ios_base&amp; (__cdecl *_Pfn)(ios_base&amp;))
		{	// call ios_base manipulator
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(bool _Val)
		{	// insert a boolean
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(short _Val)
		{	// insert a short
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());
			ios_base::fmtflags _Bfl =
				this-&gt;flags() &amp; ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned short)_Val : (long)_Val;

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

/* NOTE:
	If you are not using native wchar_t, the unsigned short inserter
	is masked by an explicit specialization that treats an unsigned
	short as a wide character.

	To read or write unsigned shorts as integers with wchar_t streams,
	make wchar_t a native type with the command line option /Zc:wchar_t.
 */

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(unsigned short _Val)
		{	// insert an unsigned short
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(int _Val)
		{	// insert an int
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());
			ios_base::fmtflags _Bfl =
				this-&gt;flags() &amp; ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned int)_Val : (long)_Val;

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(unsigned int _Val)
		{	// insert an unsigned int
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(long _Val)
		{	// insert a long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(unsigned long _Val)
		{	// insert an unsigned long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(long long _Val)
		{	// insert a long long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(unsigned long long _Val)
		{	// insert an unsigned long long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(float _Val)
		{	// insert a float
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (double)_Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(double _Val)
		{	// insert a double
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(long double _Val)
		{	// insert a long double
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(const void *_Val)
		{	// insert a void pointer
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput&amp; _Nput_fac = _STD use_facet&lt;_Nput&gt;(this-&gt;getloc());

			_TRY_IO_BEGIN
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

#if _HAS_CXX17 // LWG 2221 "No formatted output operator for nullptr"
	template&lt;class = void&gt;	// TRANSITION, ABI
		basic_ostream&amp; operator&lt;&lt;(nullptr_t)
		{	// insert a null pointer
		return (*this &lt;&lt; "nullptr");
		}
#endif // _HAS_CXX17

	basic_ostream&amp; __CLR_OR_THIS_CALL operator&lt;&lt;(_Mysb *_Strbuf)
		{	// insert until end-of-file from a stream buffer
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok &amp;&amp; _Strbuf != nullptr)
			for (int_type _Meta = _Traits::eof(); ; _Copied = true)
				{	// extract another character from stream buffer
				_TRY_BEGIN
				_Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
					? _Strbuf-&gt;sgetc() : _Strbuf-&gt;snextc();
				_CATCH_ALL
					_Myios::setstate(ios_base::failbit);
					_RERAISE;
				_CATCH_END

				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					break;	// end of file, quit

				_TRY_IO_BEGIN
					if (_Traits::eq_int_type(_Traits::eof(),
						_Myios::rdbuf()-&gt;sputc(
							_Traits::to_char_type(_Meta))))
						{	// insertion failed, quit
						_State |= ios_base::badbit;
						break;
						}
				_CATCH_IO_END
				}

		this-&gt;width(0);
		_Myios::setstate(_Strbuf == nullptr ? ios_base::badbit
			: !_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL put(_Elem _Ch)
		{	// insert a character
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	// state okay, insert character
			_TRY_IO_BEGIN
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()-&gt;sputc(_Ch)))
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL write(const _Elem *_Str,
		streamsize _Count)
		{	// insert _Count characters from array _Str
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else if (0 &lt; _Count)
			{	// state okay, insert characters
			_TRY_IO_BEGIN
			if (_Myios::rdbuf()-&gt;sputn(_Str, _Count) != _Count)
				_State |= ios_base::badbit;
			_CATCH_IO_END
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL flush()
		{	// flush output stream
		if (_Myios::rdbuf() != nullptr)
			{	// buffer exists, flush it
			const sentry _Ok(*this);

			if (_Ok &amp;&amp; _Myios::rdbuf()-&gt;pubsync() == -1)
				_Myios::setstate(ios_base::badbit);	// sync failed
			}
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL seekp(pos_type _Pos)
		{	// set output stream position to _Pos
		const sentry _Ok(*this);

		if (!this-&gt;fail()
			&amp;&amp; (off_type)_Myios::rdbuf()-&gt;pubseekpos(_Pos,
				ios_base::out) == -1)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	basic_ostream&amp; __CLR_OR_THIS_CALL seekp(off_type _Off, ios_base::seekdir _Way)
		{	// change output stream position by _Off, according to _Way
		const sentry _Ok(*this);

		if (!this-&gt;fail()
			&amp;&amp; (off_type)_Myios::rdbuf()-&gt;pubseekoff(_Off, _Way,
				ios_base::out) == -1)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type __CLR_OR_THIS_CALL tellp()
		{	// return output stream position
		const sentry _Ok(*this);

		if (!this-&gt;fail())
			return (_Myios::rdbuf()-&gt;pubseekoff(0,
				ios_base::cur, ios_base::out));
		else
			return (pos_type(-1));
		}
	};

 #pragma vtordisp(pop)	// compiler bug workaround

  #ifndef _NATIVE_WCHAR_T_DEFINED
/* NOTE:
	If you are not using native wchar_t, the following explicit
	specialization will mask the member function (above) that treats
	an unsigned short as an integer.

	To read or write unsigned shorts as integers with wchar_t streams,
	make wchar_t a native type with the command line option /Zc:wchar_t.
 */
template&lt;&gt; inline
	basic_ostream&lt;unsigned short, char_traits&lt;unsigned short&gt; &gt;&amp;
		__CLR_OR_THIS_CALL basic_ostream&lt;unsigned short,
			char_traits&lt;unsigned short&gt; &gt;::operator&lt;&lt;(unsigned short _Ch)
	{	// extract a character
	typedef char_traits&lt;unsigned short&gt; _Traits;

	ios_base::iostate _State = ios_base::goodbit;
	const sentry _Ok(*this);

	if (_Ok)
		{	// state okay, insert
		streamsize _Pad = this-&gt;width() &lt;= 1 ? 0 : this-&gt;width() - 1;

		_TRY_IO_BEGIN
		if ((this-&gt;flags() &amp; ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit &amp;&amp; 0 &lt; _Pad;
				--_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					this-&gt;rdbuf()-&gt;sputc(this-&gt;fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&amp;&amp; _Traits::eq_int_type(_Traits::eof(),
				this-&gt;rdbuf()-&gt;sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit &amp;&amp; 0 &lt; _Pad;
			--_Pad)	// pad on right
			if (_Traits::eq_int_type(_Traits::eof(),
				this-&gt;rdbuf()-&gt;sputc(this-&gt;fill())))
				_State |= ios_base::badbit;
		_CATCH_IO_END
		}

	this-&gt;width(0);
	_Myios::setstate(_State);
	return (*this);
	}
  #endif /* _NATIVE_WCHAR_T_DEFINED */

 #if defined(_DLL_CPPLIB)

  #if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT basic_ostream&lt;char,
	char_traits&lt;char&gt; &gt;;
template class _CRTIMP2_PURE_IMPORT basic_ostream&lt;wchar_t,
	char_traits&lt;wchar_t&gt; &gt;;
  #endif /* !defined(_CRTBLD) || defined(__FORCE_INSTANCE) */

  #ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE_IMPORT basic_ostream&lt;unsigned short,
	char_traits&lt;unsigned short&gt; &gt;;
  #endif /* __FORCE_INSTANCE */
 #endif /* defined(_DLL_CPPLIB) */

		// INSERTERS

template&lt;class _Elem,
	class _Traits&gt; inline
	basic_ostream&lt;_Elem, _Traits&gt;&amp; operator&lt;&lt;(
		basic_ostream&lt;_Elem, _Traits&gt;&amp; _Ostr, const char *_Val)
	{	// insert NTBS
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_CSTD strlen(_Val);	// may overflow
	streamsize _Pad = _Ostr.width() &lt;= 0 || _Ostr.width() &lt;= _Count
		? 0 : _Ostr.width() - _Count;
	const typename basic_ostream&lt;_Elem, _Traits&gt;::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	// state okay, insert characters
		_TRY_IO_BEGIN
		const ctype&lt;_Elem&gt;&amp; _Ctype_fac = _STD use_facet&lt;ctype&lt;_Elem&gt;&gt;(_Ostr.getloc());
		if ((_Ostr.flags() &amp; ios_base::adjustfield) != ios_base::left)
			for (; 0 &lt; _Pad; --_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()-&gt;sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}

		for (; _State == ios_base::goodbit &amp;&amp; 0 &lt; _Count; --_Count, ++_Val)
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()-&gt;sputc(_Ctype_fac.widen(*_Val))))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 &lt; _Pad; --_Pad)	// pad on right
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()-&gt;sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		_CATCH_IO_(_Ostr)
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template&lt;class _Elem,
	class _Traits&gt; inline
	basic_ostream&lt;_Elem, _Traits&gt;&amp; operator&lt;&lt;(
		basic_ostream&lt;_Elem, _Traits&gt;&amp; _Ostr, char _Ch)
	{	// insert a character
	ios_base::iostate _State = ios_base::goodbit;
	const typename basic_ostream&lt;_Elem, _Traits&gt;::sentry _Ok(_Ostr);

	if (_Ok)
		{	// state okay, insert
		const ctype&lt;_Elem&gt;&amp; _Ctype_fac = _STD use_facet&lt;ctype&lt;_Elem&gt;&gt;(_Ostr.getloc());
		streamsize _Pad = _Ostr.width() &lt;= 1 ? 0 : _Ostr.width() - 1;

		_TRY_IO_BEGIN
		if ((_Ostr.flags() &amp; ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit &amp;&amp; 0 &lt; _Pad;
				--_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()-&gt;sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&amp;&amp; _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()-&gt;sputc(_Ctype_fac.widen(_Ch))))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit &amp;&amp; 0 &lt; _Pad;
			--_Pad)	// pad on right
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()-&gt;sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		_CATCH_IO_(_Ostr)
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template&lt;class _Traits&gt; inline
	basic_ostream&lt;char, _Traits&gt;&amp; operator&lt;&lt;(
		basic_ostream&lt;char, _Traits&gt;&amp; _Ostr,
		const char *_Val)
<span style = "background-color:#dfd">	{	// insert NTBS into char stream</span>
	typedef char _Elem;
	typedef basic_ostream&lt;_Elem, _Traits&gt; _Myos;
<span style = "background-color:#dfd">	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow
	streamsize _Pad = _Ostr.width() &lt;= 0 || _Ostr.width() &lt;= _Count</span>
		? 0 : _Ostr.width() - _Count;
<span style = "background-color:#dfd">	const typename _Myos::sentry _Ok(_Ostr);</span>

<span style = "background-color:#dfd">	if (!_Ok)</span>
<span style = "background-color:#fdd">		_State |= ios_base::badbit;
	else</span>
		{	// state okay, insert
<span style = "background-color:#dfd">		_TRY_IO_BEGIN
		if ((_Ostr.flags() &amp; ios_base::adjustfield) != ios_base::left)
			for (; 0 &lt; _Pad; --_Pad)	// pad on left</span>
<span style = "background-color:#fdd">				if (_Traits::eq_int_type(_Traits::eof(),</span>
					_Ostr.rdbuf()-&gt;sputc(_Ostr.fill())))
					{	// insertion failed, quit
<span style = "background-color:#fdd">					_State |= ios_base::badbit;
					break;</span>
					}

<span style = "background-color:#fdd">		if (_State == ios_base::goodbit</span>
<span style = "background-color:#dfd">			&amp;&amp; _Ostr.rdbuf()-&gt;sputn(_Val, _Count) != _Count)</span>
<span style = "background-color:#fdd">			_State |= ios_base::badbit;</span>

<span style = "background-color:#dfd">		if (_State == ios_base::goodbit)
			for (; 0 &lt; _Pad; --_Pad)	// pad on right</span>
<span style = "background-color:#fdd">				if (_Traits::eq_int_type(_Traits::eof(),</span>
					_Ostr.rdbuf()-&gt;sputc(_Ostr.fill())))
					{	// insertion failed, quit
<span style = "background-color:#fdd">					_State |= ios_base::badbit;
					break;
					}</span>
<span style = "background-color:#dfd">		_Ostr.width(0);</span>
<span style = "background-color:#fdd">		_CATCH_IO_(_Ostr)</span>
		}

<span style = "background-color:#dfd">	_Ostr.setstate(_State);
	return (_Ostr);
	}</span>

template&lt;class _Traits&gt; inline
	basic_ostream&lt;char, _Traits&gt;&amp; operator&lt;&lt;(
		basic_ostream&lt;char, _Traits&gt;&amp; _Ostr, char _Ch)
	{	// insert a char into char stream
	typedef char _Elem;
	typedef basic_ostream&lt;_Elem, _Traits&gt; _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	// state okay, insert
		streamsize _Pad = _Ostr.width() &lt;= 1 ? 0 : _Ostr.width() - 1;

		_TRY_IO_BEGIN
		if ((_Ostr.flags() &amp; ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit &amp;&amp; 0 &lt; _Pad;
				--_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()-&gt;sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&amp;&amp; _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()-&gt;sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit &amp;&amp; 0 &lt; _Pad;
			--_Pad)	// pad on right
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()-&gt;sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		_CATCH_IO_(_Ostr)
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template&lt;class _Elem,
	class _Traits&gt; inline
	basic_ostream&lt;_Elem, _Traits&gt;&amp; operator&lt;&lt;(
		basic_ostream&lt;_Elem, _Traits&gt;&amp; _Ostr, const _Elem *_Val)
	{	// insert NTCS
	typedef basic_ostream&lt;_Elem, _Traits&gt; _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow
	streamsize _Pad = _Ostr.width() &lt;= 0 || _Ostr.width() &lt;= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	// state okay, insert
		_TRY_IO_BEGIN
		if ((_Ostr.flags() &amp; ios_base::adjustfield) != ios_base::left)
			for (; 0 &lt; _Pad; --_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()-&gt;sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&amp;&amp; _Ostr.rdbuf()-&gt;sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 &lt; _Pad; --_Pad)	// pad on right
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()-&gt;sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		_CATCH_IO_(_Ostr)
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template&lt;class _Elem,
	class _Traits&gt; inline
	basic_ostream&lt;_Elem, _Traits&gt;&amp; operator&lt;&lt;(
		basic_ostream&lt;_Elem, _Traits&gt;&amp; _Ostr, _Elem _Ch)
	{	// insert a character
	typedef basic_ostream&lt;_Elem, _Traits&gt; _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	// state okay, insert
		streamsize _Pad = _Ostr.width() &lt;= 1 ? 0 : _Ostr.width() - 1;

		_TRY_IO_BEGIN
		if ((_Ostr.flags() &amp; ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit &amp;&amp; 0 &lt; _Pad;
				--_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()-&gt;sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&amp;&amp; _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()-&gt;sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit &amp;&amp; 0 &lt; _Pad;
			--_Pad)	// pad on right
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()-&gt;sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		_CATCH_IO_(_Ostr)
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template&lt;class _Traits&gt; inline
	basic_ostream&lt;char, _Traits&gt;&amp; operator&lt;&lt;(
		basic_ostream&lt;char, _Traits&gt;&amp; _Ostr, const signed char *_Val)
	{	// insert a signed char NTBS
	return (_Ostr &lt;&lt; (const char *)_Val);
	}

template&lt;class _Traits&gt; inline
	basic_ostream&lt;char, _Traits&gt;&amp; operator&lt;&lt;(
		basic_ostream&lt;char, _Traits&gt;&amp; _Ostr, signed char _Ch)
	{	// insert a signed char
	return (_Ostr &lt;&lt; (char)_Ch);
	}

template&lt;class _Traits&gt; inline
	basic_ostream&lt;char, _Traits&gt;&amp; operator&lt;&lt;(
		basic_ostream&lt;char, _Traits&gt;&amp; _Ostr, const unsigned char *_Val)
	{	// insert an unsigned char NTBS
	return (_Ostr &lt;&lt; (const char *)_Val);
	}

template&lt;class _Traits&gt; inline
	basic_ostream&lt;char, _Traits&gt;&amp; operator&lt;&lt;(
		basic_ostream&lt;char, _Traits&gt;&amp; _Ostr, unsigned char _Ch)
	{	// insert an unsigned char
	return (_Ostr &lt;&lt; (char)_Ch);
	}

template&lt;class _Ostr,
	class _Ty,
	class = void&gt;
	struct _Can_stream_out
		: false_type
	{
	};

template&lt;class _Ostr,
	class _Ty&gt;
	struct _Can_stream_out&lt;_Ostr, _Ty, void_t&lt;decltype(_STD declval&lt;_Ostr&amp;&gt;() &lt;&lt; _STD declval&lt;const _Ty&amp;&gt;())&gt;&gt;
		: true_type
	{
	};

template&lt;class _Ostr,
	class _Ty,
	enable_if_t&lt;conjunction_v&lt; // prevent infinite recursion
		negation&lt;is_lvalue_reference&lt;_Ostr&gt;&gt;,
		is_base_of&lt;ios_base, _Ostr&gt;,
		_Can_stream_out&lt;_Ostr, _Ty&gt;&gt;, int&gt; = 0&gt; inline
	_Ostr&amp;&amp; operator&lt;&lt;(_Ostr&amp;&amp; _Os, const _Ty&amp; _Val)
	{	// insert to rvalue stream
	_Os &lt;&lt; _Val;
	return (_STD move(_Os));
	}

		// MANIPULATORS
template&lt;class _Elem,
	class _Traits&gt; inline
	basic_ostream&lt;_Elem, _Traits&gt;&amp;
		__CLRCALL_OR_CDECL endl(basic_ostream&lt;_Elem, _Traits&gt;&amp; _Ostr)
	{	// insert newline and flush stream
	_Ostr.put(_Ostr.widen('\n'));
	_Ostr.flush();
	return (_Ostr);
	}

template&lt;class _Elem,
	class _Traits&gt; inline
	basic_ostream&lt;_Elem, _Traits&gt;&amp;
		__CLRCALL_OR_CDECL ends(basic_ostream&lt;_Elem, _Traits&gt;&amp; _Ostr)
	{	// insert null character
	_Ostr.put(_Elem());
	return (_Ostr);
	}

template&lt;class _Elem,
	class _Traits&gt; inline
	basic_ostream&lt;_Elem, _Traits&gt;&amp;
		__CLRCALL_OR_CDECL flush(basic_ostream&lt;_Elem, _Traits&gt;&amp; _Ostr)
	{	// flush stream
	_Ostr.flush();
	return (_Ostr);
	}

		// INSERTER FOR error_category
template&lt;class _Elem,
	class _Traits&gt; inline
	basic_ostream&lt;_Elem, _Traits&gt;&amp;
		operator&lt;&lt;(basic_ostream&lt;_Elem, _Traits&gt;&amp; _Ostr,
			const error_code&amp; _Errcode)
	{	// display error code
	return (_Ostr &lt;&lt; _Errcode.category().name() &lt;&lt; ':' &lt;&lt; _Errcode.value());
	}
_STD_END

 #pragma pop_macro("new")
 _STL_RESTORE_CLANG_WARNINGS
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
#endif /* _OSTREAM_ */

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */</pre>
	</body>
</html>
<!doctype html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>iosfwd</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
// iosfwd standard header
#pragma once
#ifndef _IOSFWD_
#define _IOSFWD_
#ifndef RC_INVOKED
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cwchar&gt;
#include &lt;xstddef&gt;
#include &lt;yvals.h&gt;

#include &lt;crtdbg.h&gt;

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,_STL_WARNING_LEVEL)
 #pragma warning(disable: _STL_DISABLED_WARNINGS)
 _STL_DISABLE_CLANG_WARNINGS
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// STREAM POSITIONING TYPES (from &lt;streambuf&gt;)
using streamoff = long long;
using streamsize = long long;

		// CLASS TEMPLATE fpos (from &lt;streambuf&gt;)
template&lt;class _Statetype&gt;
	class fpos
	{	// store arbitrary file position
public:
	/* implicit */ fpos(streamoff _Off = 0)
		: _Myoff(_Off), _Fpos(0), _Mystate()
		{	// construct with stream offset
		}

	fpos(_Statetype _State, fpos_t _Fileposition)
		: _Myoff(_Fileposition), _Fpos(0), _Mystate(_State)
		{	// construct with conversion state and C file position
		}

	_NODISCARD _Statetype state() const
		{	// return conversion state
		return (_Mystate);
		}

	void state(_Statetype _State)
		{	// set conversion state
		_Mystate = _State;
		}

	operator streamoff() const
		{	// return offset
			// TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old basic_filebuf
			// would set _Fpos.
		return (_Myoff + _Fpos);
		}

#ifndef _REMOVE_FPOS_SEEKPOS
	_DEPRECATE_FPOS_SEEKPOS fpos_t seekpos() const noexcept
		{
		return {};
		}
#endif // _REMOVE_FPOS_SEEKPOS

	_NODISCARD streamoff operator-(const fpos&amp; _Right) const
		{	// return difference of file positions as an offset
		return (static_cast&lt;streamoff&gt;(*this) - static_cast&lt;streamoff&gt;(_Right));
		}

	fpos&amp; operator+=(streamoff _Off)
		{	// add offset
		_Myoff += _Off;
		return (*this);
		}

	fpos&amp; operator-=(streamoff _Off)
		{	// subtract offset
		_Myoff -= _Off;
		return (*this);
		}

	_NODISCARD fpos operator+(streamoff _Off) const
		{	// return this + offset
		fpos _Tmp = *this;
		_Tmp += _Off;
		return (_Tmp);
		}

	_NODISCARD fpos operator-(streamoff _Off) const
		{	// return this - offset
		fpos _Tmp = *this;
		_Tmp -= _Off;
		return (_Tmp);
		}

	_NODISCARD bool operator==(const fpos&amp; _Right) const
		{
		return (static_cast&lt;streamoff&gt;(*this) == static_cast&lt;streamoff&gt;(_Right));
		}

	template&lt;class _Int,
		enable_if_t&lt;is_integral_v&lt;_Int&gt;, int&gt; = 0&gt;
		_NODISCARD friend bool operator==(const fpos&amp; _Left, const _Int _Right)
		{
		return (static_cast&lt;streamoff&gt;(_Left) == _Right);
		}

	template&lt;class _Int,
		enable_if_t&lt;is_integral_v&lt;_Int&gt;, int&gt; = 0&gt;
		_NODISCARD friend bool operator==(const _Int _Left, const fpos&amp; _Right)
		{
		return (_Left == static_cast&lt;streamoff&gt;(_Right));
		}

	_NODISCARD bool operator!=(const fpos&amp; _Right) const
		{
		return (static_cast&lt;streamoff&gt;(*this) != static_cast&lt;streamoff&gt;(_Right));
		}

	template&lt;class _Int,
		enable_if_t&lt;is_integral_v&lt;_Int&gt;, int&gt; = 0&gt;
		_NODISCARD friend bool operator!=(const fpos&amp; _Left, const _Int _Right)
		{
		return (static_cast&lt;streamoff&gt;(_Left) != _Right);
		}

	template&lt;class _Int,
		enable_if_t&lt;is_integral_v&lt;_Int&gt;, int&gt; = 0&gt;
		_NODISCARD friend bool operator!=(const _Int _Left, const fpos&amp; _Right)
		{
		return (_Left != static_cast&lt;streamoff&gt;(_Right));
		}

private:
	streamoff _Myoff;	// stream offset
	fpos_t _Fpos;	// TRANSITION, ABI. C file position, not currently used
	_Statetype _Mystate;	// current conversion state
	};

using streampos = fpos&lt;_Mbstatet&gt;;
using wstreampos = streampos;

		// STRUCT TEMPLATE _Char_traits (FROM &lt;string&gt;)
template&lt;class _Elem,
	class _Int_type&gt;
	struct _Char_traits
	{	// properties of a string or stream element
	using char_type = _Elem;
	using int_type = _Int_type;
	using pos_type = streampos;
	using off_type = streamoff;
	using state_type = _Mbstatet;

	_NODISCARD static _CONSTEXPR17 int compare(_In_reads_(_Count) const _Elem * _First1,
		_In_reads_(_Count) const _Elem * _First2, size_t _Count) noexcept // strengthened
		{	// compare [_First1, _First1 + _Count) with [_First2, ...)
		for (; 0 &lt; _Count; --_Count, ++_First1, ++_First2)
			{
			if (*_First1 != *_First2)
				{
				return (*_First1 &lt; *_First2 ? -1 : +1);
				}
			}

		return (0);
		}

	_NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem * _First) noexcept // strengthened
		{	// find length of null-terminated sequence
		size_t _Count = 0;
		while (*_First != _Elem())
			{
			++_Count;
			++_First;
			}

		return (_Count);
		}

	static _Elem * copy(_Out_writes_all_(_Count) _Elem * const _First1,
		_In_reads_(_Count) const _Elem * _First2, size_t _Count) noexcept // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (static_cast&lt;_Elem *&gt;(_CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem))));
		}

	_Pre_satisfies_(_Dest_size &gt;= _Count) static _Elem * _Copy_s(
		_Out_writes_all_(_Dest_size) _Elem * const _First1, const size_t _Dest_size,
		_In_reads_(_Count) const _Elem * const _First2, const size_t _Count) noexcept
		{	// copy [_First2, _First2 + _Count) to [_First1, _First1 + _Dest_size)
		_STL_VERIFY(_Count &lt;= _Dest_size, "invalid argument");
		return (copy(_First1, _First2, _Count));
		}

	_NODISCARD static _CONSTEXPR17 const _Elem * find(_In_reads_(_Count) const _Elem * _First,
		size_t _Count, const _Elem&amp; _Ch) noexcept // strengthened
		{	// look for _Ch in [_First, _First + _Count)
		for (; 0 &lt; _Count; --_Count, ++_First)
			{
			if (*_First == _Ch)
				{
				return (_First);
				}
			}

		return (nullptr);
		}

	static _Elem * move(_Out_writes_all_(_Count) _Elem * const _First1,
		_In_reads_(_Count) const _Elem * _First2, size_t _Count) noexcept // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
		return (static_cast&lt;_Elem *&gt;(_CSTD memmove(_First1, _First2, _Count * sizeof(_Elem))));
		}

	static _Elem * assign(_Out_writes_all_(_Count) _Elem * const _First,
		size_t _Count, const _Elem _Ch) noexcept // strengthened
		{	// assign _Count * _Ch to [_First, ...)
		_Elem * _Next = _First;
		for (; 0 &lt; _Count; --_Count, ++_Next)
			{
			*_Next = _Ch;
			}

		return (_First);
		}

	static _CONSTEXPR17 void assign(_Elem&amp; _Left, const _Elem&amp; _Right) noexcept
		{	// assign an element
		_Left = _Right;
		}

	_NODISCARD static constexpr bool eq(const _Elem&amp; _Left, const _Elem&amp; _Right) noexcept
		{	// test for element equality
		return (_Left == _Right);
		}

	_NODISCARD static constexpr bool lt(const _Elem&amp; _Left, const _Elem&amp; _Right) noexcept
		{	// test if _Left precedes _Right
		return (_Left &lt; _Right);
		}

	_NODISCARD static constexpr _Elem to_char_type(const int_type&amp; _Meta) noexcept
		{	// convert metacharacter to character
		return (static_cast&lt;_Elem&gt;(_Meta));
		}

	_NODISCARD static constexpr int_type to_int_type(const _Elem&amp; _Ch) noexcept
		{	// convert character to metacharacter
		return (static_cast&lt;int_type&gt;(_Ch));
		}

	_NODISCARD static constexpr bool eq_int_type(const int_type&amp; _Left, const int_type&amp; _Right) noexcept
		{	// test for metacharacter equality
		return (_Left == _Right);
		}

	_NODISCARD static constexpr int_type not_eof(const int_type&amp; _Meta) noexcept
		{	// return anything but EOF
		return (_Meta != eof() ? _Meta : !eof());
		}

	_NODISCARD static constexpr int_type eof() noexcept
		{	// return end-of-file metacharacter
		return (static_cast&lt;int_type&gt;(EOF));
		}
	};

		// STRUCT TEMPLATE _WChar_traits
template&lt;class _Elem&gt;
	struct _WChar_traits
	{	// char_traits for the char16_t-likes: char16_t, wchar_t, unsigned short
	using char_type = _Elem;
	using int_type = unsigned short;
	using pos_type = streampos;
	using off_type = streamoff;
	using state_type = _Mbstatet;

	_NODISCARD static _CONSTEXPR17 int compare(_In_reads_(_Count) const _Elem * const _First1,
			_In_reads_(_Count) const _Elem * const _First2, const size_t _Count) noexcept // strengthened
		{	// compare [_First1, _First1 + _Count) with [_First2, ...)
#if _HAS_CXX17
		if constexpr (is_same_v&lt;_Elem, wchar_t&gt;)
			{
			return (__builtin_wmemcmp(_First1, _First2, _Count));
			}
		else
			{
			return (_Char_traits&lt;_Elem, unsigned short&gt;::compare(_First1, _First2, _Count));
			}
#else /* _HAS_CXX17 */
		return (_CSTD wmemcmp(reinterpret_cast&lt;const wchar_t *&gt;(_First1),
			reinterpret_cast&lt;const wchar_t *&gt;(_First2), _Count));
#endif /* _HAS_CXX17 */
		}

	_NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem * _First) noexcept // strengthened
		{	// find length of null-terminated sequence
#if _HAS_CXX17
		if constexpr (is_same_v&lt;_Elem, wchar_t&gt;)
			{
			return (__builtin_wcslen(_First));
			}
		else
			{
			return (_Char_traits&lt;_Elem, unsigned short&gt;::length(_First));
			}
#else /* _HAS_CXX17 */
		return (_CSTD wcslen(reinterpret_cast&lt;const wchar_t *&gt;(_First)));
#endif /* _HAS_CXX17 */
		}

	static _Elem * copy(_Out_writes_all_(_Count) _Elem * const _First1,
			_In_reads_(_Count) const _Elem * const _First2, const size_t _Count) noexcept // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (reinterpret_cast&lt;_Elem *&gt;(_CSTD wmemcpy(reinterpret_cast&lt;wchar_t *&gt;(_First1),
			reinterpret_cast&lt;const wchar_t *&gt;(_First2), _Count)));
		}

	_Pre_satisfies_(_Size_in_words &gt;= _Count) static _Elem * _Copy_s(
			_Out_writes_all_(_Size_in_words) _Elem * const _First1, const size_t _Size_in_words,
			_In_reads_(_Count) const _Elem * const _First2, const size_t _Count) noexcept
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		_STL_VERIFY(_Count &lt;= _Size_in_words, "invalid argument");
		return (copy(_First1, _First2, _Count));
		}

	_NODISCARD static _CONSTEXPR17 const _Elem * find(_In_reads_(_Count) const _Elem * _First,
			const size_t _Count, const _Elem&amp; _Ch) noexcept // strengthened
		{	// look for _Ch in [_First, _First + _Count)
#if _HAS_CXX17
		if constexpr (is_same_v&lt;_Elem, wchar_t&gt;)
			{
			return (__builtin_wmemchr(_First, _Ch, _Count));
			}
		else
			{
			return (_Char_traits&lt;_Elem, unsigned short&gt;::find(_First, _Count, _Ch));
			}
#else /* _HAS_CXX17 */
		return (reinterpret_cast&lt;const _Elem *&gt;(_CSTD wmemchr(
			reinterpret_cast&lt;const wchar_t *&gt;(_First), _Ch, _Count)));
#endif /* _HAS_CXX17 */
		}

	static _Elem * move(_Out_writes_all_(_Count) _Elem * const _First1,
			_In_reads_(_Count) const _Elem * const _First2, const size_t _Count) noexcept // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (reinterpret_cast&lt;_Elem *&gt;(_CSTD wmemmove(reinterpret_cast&lt;wchar_t *&gt;(_First1),
			reinterpret_cast&lt;const wchar_t *&gt;(_First2), _Count)));
		}

	static _Elem * assign(_Out_writes_all_(_Count) _Elem * const _First, size_t _Count, _Elem _Ch)
			noexcept // strengthened
		{	// assign _Count * _Ch to [_First, ...)
		return (reinterpret_cast&lt;_Elem *&gt;(_CSTD wmemset(reinterpret_cast&lt;wchar_t *&gt;(_First), _Ch, _Count)));
		}

	static _CONSTEXPR17 void assign(_Elem&amp; _Left, const _Elem&amp; _Right) noexcept
		{	// assign an element
		_Left = _Right;
		}

	_NODISCARD static constexpr bool eq(const _Elem&amp; _Left, const _Elem&amp; _Right) noexcept
		{	// test for element equality
		return (_Left == _Right);
		}

	_NODISCARD static constexpr bool lt(const _Elem&amp; _Left, const _Elem&amp; _Right) noexcept
		{	// test if _Left precedes _Right
		return (_Left &lt; _Right);
		}

	_NODISCARD static constexpr _Elem to_char_type(const int_type&amp; _Meta) noexcept
		{	// convert metacharacter to character
		return (_Meta);
		}

	_NODISCARD static constexpr int_type to_int_type(const _Elem&amp; _Ch) noexcept
		{	// convert character to metacharacter
		return (_Ch);
		}

	_NODISCARD static constexpr bool eq_int_type(const int_type&amp; _Left, const int_type&amp; _Right) noexcept
		{	// test for metacharacter equality
		return (_Left == _Right);
		}

	_NODISCARD static constexpr int_type not_eof(const int_type&amp; _Meta) noexcept
		{	// return anything but EOF
		return (_Meta != eof() ? _Meta : static_cast&lt;int_type&gt;(!eof()));
		}

	_NODISCARD static constexpr int_type eof() noexcept
		{	// return end-of-file metacharacter
		return (WEOF);
		}
	};

		// STRUCT TEMPLATE char_traits
template&lt;class _Elem&gt;
	struct char_traits
		: _Char_traits&lt;_Elem, long&gt;
	{	// properties of a string or stream unknown element
	};

		// STRUCT char_traits&lt;char16_t&gt;
template&lt;&gt;
	struct char_traits&lt;char16_t&gt;
		: _WChar_traits&lt;char16_t&gt;
	{	// properties of a string or stream char16_t element
	};

using u16streampos = streampos;

		// STRUCT char_traits&lt;char32_t&gt;
template&lt;&gt;
	struct char_traits&lt;char32_t&gt;
		: _Char_traits&lt;char32_t, unsigned int&gt;
	{	// properties of a string or stream char32_t element
	};

using u32streampos = streampos;

		// STRUCT char_traits&lt;wchar_t&gt;
template&lt;&gt;
	struct char_traits&lt;wchar_t&gt;
		: _WChar_traits&lt;wchar_t&gt;
	{	// properties of a string or stream wchar_t element
	};

 #ifdef _NATIVE_WCHAR_T_DEFINED
		// STRUCT char_traits&lt;unsigned short&gt;
template&lt;&gt;
	struct char_traits&lt;unsigned short&gt;
		: _WChar_traits&lt;unsigned short&gt;
	{	// properties of a string or stream unsigned short element
	};
 #endif /* _NATIVE_WCHAR_T_DEFINED */

		// STRUCT char_traits&lt;char&gt; (FROM &lt;string&gt;)
template&lt;&gt;
	struct char_traits&lt;char&gt;
	{	// properties of a string or stream char element
	using char_type = char;
	using int_type = int;
	using pos_type = streampos;
	using off_type = streamoff;
	using state_type = _Mbstatet;

	_NODISCARD static _CONSTEXPR17 int compare(_In_reads_(_Count) const char * const _First1,
		_In_reads_(_Count) const char * const _First2, const size_t _Count) noexcept // strengthened
		{	// compare [_First1, _First1 + _Count) with [_First2, ...)
#if _HAS_CXX17
		return (__builtin_memcmp(_First1, _First2, _Count));
#else /* _HAS_CXX17 */
		return (_CSTD memcmp(_First1, _First2, _Count));
#endif /* _HAS_CXX17 */
		}

	_NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const char * const _First) noexcept // strengthened
<span style = "background-color:#dfd">		{	// find length of null-terminated string</span>
#if _HAS_CXX17
		return (__builtin_strlen(_First));
#else /* _HAS_CXX17 */
<span style = "background-color:#dfd">		return (_CSTD strlen(_First));</span>
#endif /* _HAS_CXX17 */
<span style = "background-color:#dfd">		}</span>

	static char * copy(_Out_writes_(_Count) char * const _First1,
		_In_reads_(_Count) const char * const _First2, const size_t _Count) noexcept // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (static_cast&lt;char *&gt;(_CSTD memcpy(_First1, _First2, _Count)));
		}

	_Pre_satisfies_(_Size_in_bytes &gt;= _Count) static char * _Copy_s(
		_Out_writes_all_(_Size_in_bytes) char * const _First1, const size_t _Size_in_bytes,
		_In_reads_(_Count) const char * const _First2, const size_t _Count) noexcept
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		_STL_VERIFY(_Count &lt;= _Size_in_bytes, "invalid argument");
		return (copy(_First1, _First2, _Count));
		}

	_NODISCARD static _CONSTEXPR17 const char * find(_In_reads_(_Count) const char * const _First,
		const size_t _Count, const char&amp; _Ch) noexcept // strengthened
		{	// look for _Ch in [_First, _First + _Count)
#if _HAS_CXX17
		return (__builtin_char_memchr(_First, _Ch, _Count));
#else /* _HAS_CXX17 */
		return (static_cast&lt;const char *&gt;(_CSTD memchr(_First, _Ch, _Count)));
#endif /* _HAS_CXX17 */
		}

	static char * move(_Out_writes_all_(_Count) char * const _First1,
		_In_reads_(_Count) const char * const _First2, const size_t _Count) noexcept // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (static_cast&lt;char *&gt;(_CSTD memmove(_First1, _First2, _Count)));
		}

	static char * assign(_Out_writes_all_(_Count) char * const _First,
		const size_t _Count, const char _Ch) noexcept // strengthened
		{	// assign _Count * _Ch to [_First, ...)
		return (static_cast&lt;char *&gt;(_CSTD memset(_First, _Ch, _Count)));
		}

	static _CONSTEXPR17 void assign(char&amp; _Left, const char&amp; _Right) noexcept
		{	// assign an element
		_Left = _Right;
		}

	_NODISCARD static constexpr bool eq(const char&amp; _Left, const char&amp; _Right) noexcept
		{	// test for element equality
		return (_Left == _Right);
		}

	_NODISCARD static constexpr bool lt(const char&amp; _Left, const char&amp; _Right) noexcept
		{	// test if _Left precedes _Right
		return (static_cast&lt;unsigned char&gt;(_Left) &lt; static_cast&lt;unsigned char&gt;(_Right));
		}

	_NODISCARD static constexpr char to_char_type(const int_type&amp; _Meta) noexcept
		{	// convert metacharacter to character
		return (static_cast&lt;char&gt;(_Meta));
		}

	_NODISCARD static constexpr int_type to_int_type(const char&amp; _Ch) noexcept
		{	// convert character to metacharacter
		return (static_cast&lt;unsigned char&gt;(_Ch));
		}

	_NODISCARD static constexpr bool eq_int_type(const int_type&amp; _Left, const int_type&amp; _Right) noexcept
<span style = "background-color:#fdd">		{	// test for metacharacter equality
		return (_Left == _Right);
		}</span>

	_NODISCARD static constexpr int_type not_eof(const int_type&amp; _Meta) noexcept
		{	// return anything but EOF
		return (_Meta != eof() ? _Meta : !eof());
		}

	_NODISCARD static constexpr int_type eof() noexcept
<span style = "background-color:#fdd">		{	// return end-of-file metacharacter
		return (EOF);
		}</span>
	};

		// FORWARD REFERENCES
template&lt;class _Ty&gt;
	class allocator;
class ios_base;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;&gt;
	class basic_ios;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;&gt;
	class istreambuf_iterator;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;&gt;
	class ostreambuf_iterator;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;&gt;
	class basic_streambuf;

#pragma vtordisp(push, 2)	// compiler bug workaround
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;&gt;
	class basic_istream;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;&gt;
	class basic_ostream;
#pragma vtordisp(pop)	// compiler bug workaround

template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;&gt;
	class basic_iostream;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;,
	class _Alloc = allocator&lt;_Elem&gt;&gt;
	class basic_stringbuf;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;,
	class _Alloc = allocator&lt;_Elem&gt;&gt;
	class basic_istringstream;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;,
	class _Alloc = allocator&lt;_Elem&gt;&gt;
	class basic_ostringstream;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;,
	class _Alloc = allocator&lt;_Elem&gt;&gt;
	class basic_stringstream;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;&gt;
	class basic_filebuf;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;&gt;
	class basic_ifstream;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;&gt;
	class basic_ofstream;
template&lt;class _Elem,
	class _Traits = char_traits&lt;_Elem&gt;&gt;
	class basic_fstream;

 #if defined(_DLL_CPPLIB)
template&lt;class _Elem,
	class _InIt &gt;
	class num_get;
template&lt;class _Elem,
	class _OutIt &gt;
	class num_put;
template&lt;class _Elem&gt;
	class collate;
 #endif /* defined(_DLL_CPPLIB) */

		// char TYPEDEFS
using ios = basic_ios&lt;char, char_traits&lt;char&gt;&gt;;
using streambuf = basic_streambuf&lt;char, char_traits&lt;char&gt;&gt;;
using istream = basic_istream&lt;char, char_traits&lt;char&gt;&gt;;
using ostream = basic_ostream&lt;char, char_traits&lt;char&gt;&gt;;
using iostream = basic_iostream&lt;char, char_traits&lt;char&gt;&gt;;
using stringbuf = basic_stringbuf&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt;&gt;;
using istringstream = basic_istringstream&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt;&gt;;
using ostringstream = basic_ostringstream&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt;&gt;;
using stringstream = basic_stringstream&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt;&gt;;
using filebuf = basic_filebuf&lt;char, char_traits&lt;char&gt;&gt;;
using ifstream = basic_ifstream&lt;char, char_traits&lt;char&gt;&gt;;
using ofstream = basic_ofstream&lt;char, char_traits&lt;char&gt;&gt;;
using fstream = basic_fstream&lt;char, char_traits&lt;char&gt;&gt;;

		// wchar_t TYPEDEFS
using wios = basic_ios&lt;wchar_t, char_traits&lt;wchar_t&gt;&gt;;
using wstreambuf = basic_streambuf&lt;wchar_t, char_traits&lt;wchar_t&gt;&gt;;
using wistream = basic_istream&lt;wchar_t, char_traits&lt;wchar_t&gt;&gt;;
using wostream = basic_ostream&lt;wchar_t, char_traits&lt;wchar_t&gt;&gt;;
using wiostream = basic_iostream&lt;wchar_t, char_traits&lt;wchar_t&gt;&gt;;
using wstringbuf = basic_stringbuf&lt;wchar_t, char_traits&lt;wchar_t&gt;, allocator&lt;wchar_t&gt;&gt;;
using wistringstream = basic_istringstream&lt;wchar_t, char_traits&lt;wchar_t&gt;, allocator&lt;wchar_t&gt;&gt;;
using wostringstream = basic_ostringstream&lt;wchar_t, char_traits&lt;wchar_t&gt;, allocator&lt;wchar_t&gt;&gt;;
using wstringstream = basic_stringstream&lt;wchar_t, char_traits&lt;wchar_t&gt;, allocator&lt;wchar_t&gt;&gt;;
using wfilebuf = basic_filebuf&lt;wchar_t, char_traits&lt;wchar_t&gt;&gt;;
using wifstream = basic_ifstream&lt;wchar_t, char_traits&lt;wchar_t&gt;&gt;;
using wofstream = basic_ofstream&lt;wchar_t, char_traits&lt;wchar_t&gt;&gt;;
using wfstream = basic_fstream&lt;wchar_t, char_traits&lt;wchar_t&gt;&gt;;

 #if defined(_CRTBLD)
		// unsigned short TYPEDEFS
using ushistream = basic_istream&lt;unsigned short, char_traits&lt;unsigned short&gt;&gt;;
using ushostream = basic_ostream&lt;unsigned short, char_traits&lt;unsigned short&gt;&gt;;
using ushfilebuf = basic_filebuf&lt;unsigned short, char_traits&lt;unsigned short&gt;&gt;;
 #endif /* defined(_CRTBLD) */
_STD_END

 #pragma pop_macro("new")
 _STL_RESTORE_CLANG_WARNINGS
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
#endif /* _IOSFWD_ */

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */</pre>
	</body>
</html>